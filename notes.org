* 2012-06-19: Week 1 Tuesday
** FastISel
*** Rust doesn't call SelectionDAG or FastISel directly, but through an LLVM pass.
*** Some function is responsible for setting up the instruction selector (addISelToPass or somesuch).
*** Need to add fast-isel-abort parameter to this pass so the FastISel knows not to fall back to SelectionDAG.
*** Rust compilation happens in three phases:
**** Stage 0: Download binary from server.
**** Stage 1: Compile rustc with binary.
**** Stage 2: Compile rustc with itself.
**** Stage 3: Compile rustc with itself again to check stability.
*** If you swap in FastISel, then you might only be able to get through stage 1 (i.e. rustc might not be able to compile itself), but you should be able to still try some simple testcases.
*** See how many testcases you can do, then switch over to other stuff.
** Roadmap (as far as I can remember)
*** ISel
**** FastISel and fast-isel-abort
**** Merge work on FastISel
**** Finish work on SelectionDAG
*** Unwinding
*** ???
* 2012-06-20: Week 1 Wednesday
** Still looking for the call that sets the ISel parameters
*** The rustc backend calls addPassesToEmitFile for codegen (rustllvm/RustWrapper.cpp)
**** ==> calls addPassesToGenerateCode
**** ==> sets TargetMachine::setFastISel and calls TargetPassConfig::addInstSelector (abstract method)
**** ==> X86PassConfig::addInstSelector ==> createX86ISelDag ==> new X86DAGToDAGISel
*** -fast-isel-abort is specified in SelectionDAGISel.cpp
**** SelectionDAGISel.cpp is an LLVM pass that takes -fast-isel-abort as a command line param
***** -fast-isel on the other hand is passed via the TargetMachine and PassConfig
**** SelectionDAGISel does NOT pass -fast-isel-abort to the TargetMachine when it creates the FastISel
**** SelectionDAGISel manually calls the FastISel when doing codegen
**** So it just aborts manually when FastISel fails to select all instructions for a block. (See lines 1140-1143.)
***** if (EnableFastISelAbort) llvm_unreachable(...);
*** Got -fast-isel-abort to work by hard-coding it in SelectionDAGISel.cpp

diff --git a/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp b/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp
index 2c149da..c0aaf13 100644
--- a/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp
+++ b/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp
@@ -54,6 +54,7 @@
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/ADT/Statistic.h"
 #include <algorithm>
+#include <cstdio>
 using namespace llvm;
 
 STATISTIC(NumFastIselFailures, "Number of instructions fast isel failed on");
@@ -340,6 +341,11 @@ bool SelectionDAGISel::runOnMachineFunction(MachineFunction &mf) {
   assert((!EnableFastISelAbort || TM.Options.EnableFastISel) &&
          "-fast-isel-abort requires -fast-isel");
 
+  if (TM.Options.EnableFastISel) EnableFastISelAbort = true; // Elliott
+  printf("Elliott: This is SelectionDAGISel.\n");
+  printf("Elliott: -fast-isel is %d.\n", TM.Options.EnableFastISel);
+  printf("Elliott: -fast-isel-abort is %d.\n", !!EnableFastISelAbort);
+
   const Function &Fn = *mf.getFunction();
   const TargetInstrInfo &TII = *TM.getInstrInfo();
   const TargetRegisterInfo &TRI = *TM.getRegisterInfo();

*** But FastISel can't compile any non-trivial program anyway, so it doesn't seem to help

$ cat test.rs
fn main () {
    io::println("hi");
}

$ rustc test.rs
Elliott: This is SelectionDAGISel.
Elliott: -fast-isel is 1.
Elliott: -fast-isel-abort is 1.
FastISel missed terminator:   invoke void @_ZN2io7println17_7bd51147c9de282c3_02E(i1* undef, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6)
          to label %7 unwind label %8
FastISel miss:   store { i8*, i32 } %9, { i8*, i32 }* %2
FastISel didn't select the entire block
UNREACHABLE executed at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:1149!
Stack dump:
0.	Running pass 'Function Pass Manager' on module 'test.rc'.
1.	Running pass 'X86 DAG->DAG Instruction Selection' on function '@_ZN4main17_f8ae15773a042ac13_00E'
Aborted (core dumped)

*** It can at least do basic arithmetic

$ cat test.rs
fn main () {
    let mut a = 5, b = 6;
    a += b;
    os::set_exit_status(a);
}

$ rustc test.rs
Elliott: This is SelectionDAGISel.
Elliott: -fast-isel is 1.
Elliott: -fast-isel-abort is 1.
[...]

$ ./test; echo $?
11

*** 37% of the tests pass in rust/src/test/run-pass
*** A lot of tests seem to be failing from store instructions
**** store { i8*, i32 } %9, { i8*, i32 }* %2
**** Looks like the unwind handler for a call, because this is preceded by

    ; <label>:4                                       ; preds = %3
      %5 = call i8* @upcall_str_new_uniq(i8* getelementptr inbounds ([3 x i8]* @str1, i32 0, i32 0), i32 2)
      %6 = bitcast i8* %5 to { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)*
      invoke void @_ZN2io7println17_7bd51147c9de282c3_02E(i1* undef, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6)
>>>>          to label %7 unwind label %8                                                           <<<< note unwind label

    ; <label>:7                                       ; preds = %4
      br label %14

    ; <label>:8                                       ; preds = %4
      %9 = landingpad { i8*, i32 } personality i32 ()* @upcall_rust_personality
              cleanup
      call void @upcall_reset_stack_limit()
>>>>  store { i8*, i32 } %9, { i8*, i32 }* %2                                                       <<<< error here
      br label %10

    ; <label>:10                                      ; preds = %8
      %11 = bitcast { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6 to i8*
>>>>  call void @glue_free3(i1* null, i1* null, %tydesc** null, i8* %11)                            <<<< clean up memory
      %12 = load { i8*, i32 }* %2
      resume { i8*, i32 } %12
    
    ; <label>:13                                      ; preds = %14
>>>>  br label %return                                                                              <<<< success return path

    ; <label>:14                                      ; preds = %7
      %15 = bitcast { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6 to i8*
      call void @glue_free3(i1* null, i1* null, %tydesc** null, i8* %15)
      br label %13

** Need to grill Patrick (pcwalton) again to figure out which of his branches I'm interested in
*** gc? (11 months old)
*** backpointers? (20 months old)
*** unique-imm? (10 months old)
*** Others don't look relevant.
* 2012-06-21: Week 1 Thursday
** Continued ISel hacking
*** Store instructions come from stack unwinding (get_landing_pad in rustc/middle/trans/base.rs)
**** invoke is an LLVM instruction which branches when an exception is hit
**** landingpad is an LLVM instruction which returns the exception data
**** resume is an LLVM instruction which resumes unwinding the stack
**** Some runtime functions interact with exception handling
***** upcall_reset_stack_limit / upcalls.reset_stack_limit -- for fiddling with the Rust stack
***** upcall_rust_personality / upcalls.rust_personality -- returns exception handler metadata
*** I replaced the failing store instruction with the following

  %v1 = extractvalue { i8*, i32 } %9, 0
  %v2 = extractvalue { i8*, i32 } %9, 1
  %p1 = getelementptr { i8*, i32 }* %2, i32 0, i32 0
  %p2 = getelementptr { i8*, i32 }* %2, i32 0, i32 1
  store i8* %v1, i8** %p1
  store i32 %v2, i32* %p2
; store { i8*, i32 } %9, { i8*, i32 }* %2

*** And now it fails on the landingpad instruction

%8 = landingpad { i8*, i32 } personality i32 ()* @upcall_rust_personality cleanup

*** I'm pretty sure there's no way to get around this one
** Chat with Patrick (pcwalton)
*** Rust currently uses landing pads and DWARF C++ exception handlers to free unique pointers (~) (i.e. exchange heaps)
*** But errors are non-recoverable anyway (try/catch only at task call boundaries), so we really don't need anything that fancy
*** Walk the stack to find free unique pointers (~) and free them (and delete the landing pads)
*** Patrick already has a branch with the GC changes necessary to start work on this
**** https://github.com/pcwalton/llvm/tree/noteroots-ir
**** But it only supports FastISel, so you're going to have to start there
**** (I'm still not sure I understand *what* these GC changes are exactly, but whatever)
*** Initial step is to set up the basic stack walking and cleanup
**** Add gc "generic" (<== name of the gc he wrote) to functions
***** This should add stack maps to generated assembly for these functions
**** Simple test program

let x : ~int = 3; // Create a unique box with 3 in it
fail;             // Then crash and see what happens

** Progress (or not)
*** Downloaded pcwalton's llvm branch
*** His branch had an issue with LLVMLinkModules being linked multiple times, but I think I fixed it (by deleting the rust copy, which didn't appear to be used anyway)
*** Rust build is crashing in Live IR Variables pass, which is something pcwalton added
**** Here's the backtrace

#0  0xb4be87a0 in llvm::Value::getValueID (this=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Value.h:228
#1  0xb4be8945 in llvm::Instruction::getOpcode (this=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Instruction.h:82
#2  0xb4be895b in llvm::Instruction::isTerminator (this=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Instruction.h:85
#3  0xb4be9261 in llvm::TerminatorInst::classof (I=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/InstrTypes.h:78
#4  0xb4bfc58c in llvm::isa_impl<llvm::TerminatorInst, llvm::Instruction>::doit (Val=...) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:50
#5  0xb4bf9057 in llvm::isa_impl_cl<llvm::TerminatorInst, llvm::Instruction*>::doit (Val=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:68
#6  0xb4bf3ed4 in llvm::isa_impl_wrap<llvm::TerminatorInst, llvm::Instruction*, llvm::Instruction*>::doit (Val=@0xb40febdc: 0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:99
#7  0xb4bef425 in llvm::isa<llvm::TerminatorInst, llvm::Instruction*> (Val=@0xb40febdc: 0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:110
#8  0xb541b825 in llvm::dyn_cast<llvm::TerminatorInst, llvm::Instruction*> (Val=@0xb40febdc: 0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:220
#9  0xb54e68eb in llvm::BasicBlock::getTerminator (this=0xb1ff7734) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/BasicBlock.cpp:122
#10 0xb4ca56e9 in llvm::succ_begin (BB=0xb1ff7734) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/CFG.h:227
#11 0xb50330f5 in llvm::LiveIRVariables::computeBackAndIncomingEdges (this=0xb1e81da8, F=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:92
#12 0xb5032e56 in llvm::LiveIRVariables::runOnFunction (this=0xb1e81da8, F=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:59
#13 0xb55e4514 in llvm::FPPassManager::runOnFunction (this=0xb3ccb810, F=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1479
#14 0xb55e46d0 in llvm::FPPassManager::runOnModule (this=0xb3ccb810, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1499
#15 0xb55e49ae in llvm::MPPassManager::runOnModule (this=0xb2ff4e18, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1553
#16 0xb55e4e58 in llvm::PassManagerImpl::run (this=0xb2e86858, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1636
#17 0xb55e4ff5 in llvm::PassManager::run (this=0xb2e52990, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1665
#18 0xb4bcda09 in LLVMRustWriteOutputFile (PMR=0xb2e52990, M=0xb2eaf120, triple=0xb41037c0 "i686-unknown-linux-gnu",
    path=0xb212b820 "i686-unknown-linux-gnu/stage1/lib/rustc/i686-unknown-linux-gnu/lib/libcore.o", FileType=llvm::TargetMachine::CGFT_ObjectFile, OptLevel=llvm::CodeGenOpt::None,
    EnableSegmentedStacks=true) at /home/elliottslaughter/rust/src/rustllvm/RustWrapper.cpp:101
#19 0xb6cb7530 in LLVMRustWriteOutputFile__c_stack_shim () from /home/elliottslaughter/rust/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.2.so
#20 0xb615190f in __morestack () from /home/elliottslaughter/rust/i686-unknown-linux-gnu/stage1/bin/../lib/librustrt.so

*** Yup, sounds like fun (or not)
* 2012-06-22: Week 1 Friday
** Debugging Live IR Variables (llvm/lib/CodeGen/LiveIRVariables.cpp)
*** Crash computeBackAndIncomingEdges appears to come from having a BB with a null pointer in its instruction list
*** Noticed SmallVector<16> and SmallSet<16>, and function has more than 16 BBs
**** Tried 64 instead of 16, and crash was delayed for about 20 more functions
**** But the API claims it will allocate heap space when fixed stack space is used up, so how on earth does this matter?
**** Maybe there is some other memory corruption and I'm just avoiding it with extra padding?
**** Could it be inserting into the vector while iterating it?

for (SmallVector<BasicBlock *, 64>::iterator BBI = WorkList.begin();
                                             BBI != WorkList.end(); ++BBI) {
  // ...
  for (succ_iterator SI = succ_begin(*BBI),
                     SE = succ_end(*BBI); SI != SE; ++SI) {
     // ...

     WorkList.push_back(*SI);
  }
}

*** Crash moved down to computeReachableBackEdges (_ZN3int5range17_6b446dc7ab6447ad3_02E)
**** Assertion `t <= i && "Theorem 3 was violated!"' failed
**** Problem appears to be (at least partially) upstream of the assertion failure
*** Graphviz diagram for the block control flow

digraph _ZN3int5range17_6b446dc7ab6447ad3_02E {

bb0 -> bb1
bb1 -> bb2
bb2 -> bb3
bb3 -> bb4
bb4 -> bb5
bb4 -> bb9
bb5 -> bb6
bb6 -> bb7
bb7 -> bb8
bb7 -> bb11
bb8 -> bb9
bb9 -> bb10
bb11 -> bb12
bb12 -> bb4

}

*** Problems I found in the reachability algorithms
**** Take this all with a grain of salt because I'm still not sure how this is being used
**** computeBackAndIncomingEdges has an issue where it will find back edges in a DAG with no cycles
***** Changed BFS to DFS to allow me to track the path to the current node for cycle detection
**** computeTopologicalOrdering has an issue where it is ordering nodes incorrectly
***** Actually that problem is in computeBackAndIncomingEdges because the incoming counts are wrong (need to count edges from nodes we've already visited, but NOT if they're on the path to the current node)
*** Now the results look right for that function, but it's crashing later on (in a debug function???)
**** Backtrace

#0  0xb4f53adb in llvm::BitVector::find_first (this=0xb3299ef4) at /home/elliottslaughter/rust/src/llvm/include/llvm/ADT/BitVector.h:146
#1  0xb50353c6 in llvm::LiveIRVariables::isLiveIn (this=0xb21c0b68, V=..., BB=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:272
#2  0xb50358ce in llvm::LiveIRVariables::dump (this=0xb21c0b68, F=..., IncludeDead=false) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:351
#3  0xb5033fe4 in llvm::LiveIRVariables::runOnFunction (this=0xb21c0b68, F=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:68

*** Turned off debugging, problem "solved"
*** Rustc now compiles itself!!!
*** (Virtual) Tomorrow (a.k.a. Monday): Cleanup patches to make rustc work with the new llvm, then move on to turning on GC on functions
* 2012-06-22: Week 1 Summary
** Tried to reconstruct roadmap
** Traced FastISel through the system and found a hack to enable it
** Found conflict between FastISel and landing pads
** Got Patrick's noteroots-ir branch, first pass compiling rustc with branch
** Fixed LiveIRVariables crashes
* 2012-06-25: Week 2 Monday
** First pass turning on GC "generic"
*** Rustc can't be compiled because SelectionDAG doesn't know what to do about gcregroot intrinsics, and FastISel can't handle other things (sdiv)
*** Maybe do proper command line parsing rather than mashing the value of -fast-isel-abort to true?
**** Hoping that the FastISel can handle the gcregroot intrinsics and leave everything else to the SelectionDAG
**** No, SelectionDAG still gets confused, even when delegating to FastISel
*** Maybe I could add a flag to rustc to enable GC "generic"?
**** I added a --gc flag to rustc to turn on GC. Moving along now.
*** Failed compile box.rs with GC: upcall_fail requires a landing pad

fn main() {
  let x = ~3;
  fail;
}

*** Potential ways forward?
**** Fix SelectDAG for new GC intrinsics
**** Rip out error handling and write the stack walker
*** Random questions
**** Does it really make any sense to mark unique pointers as GC roots? They're not going to be GC'd.
**** Does the existing "generic" GC generate any GC roots? Don't we need to generate those in rustc?
***** The GCStrategy appears to add GC roots itself.
**** Where is does the stack map go and what format do we generate it in? Does it contain any sort of type information?
***** See llvm/lib/CodeGen/AsmPrinter/GenericGCPrinter.cpp
***** Look for frametable at the end of the data section
**** What are the semantics of gcregroot? How will we access values in registers? Will we write the registers to the stack map? We can't actually safely run the GC without dumping these to memory anyway, right?
***** My best guess is the callee saves the registers before initiating any GC. Then the GC needs to know where those got put on the stack.
* 2012-06-26: Week 2 Tuesday
** Adgenda
*** Find stack map and make sure it gets in the binary
*** Write stack walker for runtime
*** Delete C++ error handler and see if that lets me compile things (albeit with memory leaks)
*** Fix memory leaks by using stack walker to clean up unique pointers
** Progress
*** Stack map format (llvm/lib/CodeGen/AsmPrinter/GenericGCPrinter.cpp)

Symbol: '_gc_metadata' + mangled(fn_name)

struct function_metadata {
  .align(pointer)
  num_callee_saved_regs : i32
  num_safe_points       : i32

  // callee saved regs
  stack_offsets         : [i32 * num_callee_saved_regs]
  register              : [i8 * num_callee_saved_regs]

  // safe points
  .align(pointer)
  safe_point_name       : [sp_name * num_safe_points]
  safe_points_info      : [sp_info * num_safe_points]

  struct sp_name {
    safe_point_address    : pointer
    safe_point_symbol     : pointer
  }

  struct sp_info {
    .align(pointer)
    num_stack_roots     : i32
    num_reg_roots       : i32

    stack_root_offsets  : [i32 * num_stack_roots]
    reg_roots           : [i8 * num_reg_roots]
    address_space       : [i8 * (num_stack_roots + num_reg_roots)]
  }
}

*** To list symbols: objdump --syms <binary>
*** To get data section contents: objdump --full-contents --section=.data <binary>
** Chat with Patrick and Brian
*** Patrick gave me access to his llvm fork on github so I can push fixes to Live IR Variables
*** libcore currently contains a basic stack walker that just chases frame pointers
*** ./configure --disable-manage-submodules to stop rust from messing with your submodules
*** For error handling, add a -Z no-landing-pads flag to turn off landing pads
*** The new error handling will run on the rust stack without needing C++ exceptions
**** Instead of fail turning into a call to C++ upcall_fail(), it will call a rust function fail()
**** Then you'll walk the stack in rust code, clean everything up, and issue a context switch back into the scheduler
** New Adgenda
*** Try core::walk_stack (without GC, because this is a rust call)
*** Add flag to turn off landing pads
*** Use core::walk_stack to print GC roots (requires landing pads be off)
** Progress (again)
*** core::walk_stack doesn't actually work as advertised
**** frame_address intrinsic never calls closure
**** Name mangling is failing, causing the frame_address intrinsic and its wrapper to be called by the same name
***** Note: This is because internally trans inserts another wrapper for intrinsics (that is, we have *two* wrappers, and they have the same name)
**** Workaround is to rename frame_address wrapper in libcore/stackwalk.rs
**** Permanent solution is probably to fix intrinsic mangling in rustc/middle/trans/base.rs
**** Bailing for now, I have a workaround, so I'll let someone else fix this
* 2012-06-29: Week 2 Friday
** Adgenda
*** Add flag to turn off landing pads
*** Use core::walk_stack to print GC roots (requires landing pads be off)
** Progress
*** Turning off landing pads
**** rustc/middle/trans/base.rs has a function needs_invoke which looks like the right place
**** It works!!! I got a memory leak!

$ cat unique-box.rs
fn main() {
  let x = ~3;
  fail;
}

$ rustc --gc -Z no-landing-pads unique-box.rs
unique-box.rs:2:6: 2:7 warning: unused variable: `x`
unique-box.rs:2   let x = ~3;
                      ^
$ ./unique-box
rust: upcall fail 'explicit failure', unique-box.rs:3
rust: domain main @0x9944ed0 root task failed
leaked memory in rust main loop (1 objects)
unique-box: /home/elliottslaughter/rust/src/rt/memory_region.cpp:172: memory_region::~memory_region(): Assertion `false' failed.
Aborted (core dumped)

*** Printing GC roots
**** GC lowering is crashing due to reinterpret_cast

rustc: /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:194: typename llvm::cast_retty<To, From>::ret_type llvm::cast(const Y&) [with X = llvm::PointerType, Y = llvm::Type*, typename llvm::cast_retty<To, From>::ret_type = llvm::PointerType*]: Assertion `isa<X>(Val) && "cast<Ty>() argument of incompatible type!"' failed.
Stack dump:
0.      Running pass 'Function Pass Manager' on module 'stack-test.rc'.
1.      Running pass 'Lower Garbage Collection Instructions' on function '@_ZN3bar4anonE'
Aborted (core dumped)

**** Removing the reinterpret_cast fixes the problem, but then I can't use the value
**** Looks like it's coming from LowerIntrinsics::InsertRootInitializers
***** Need to read that code, not sure what's going on
*** Also found a bug in LowerIntrinsics::PerformDefaultLowering
**** Loop iterator bounds getting mixed up
**** I hope this fixes the other problem, but I wouldn't bet on it
*** In other news, 80% of tests can be compiled with --gc -Z no-landing-pads
* 2012-06-29: Week 2 Summary
** Added --gc flag, tried to turn on GC in rustc
** Discovered stack map format
** Discovered bug in compilation of stack walker, stack walking on hold until bug fix arrives
** Google I/O
** Add -Z no-landing-pads flag, initial testing of GC without landing pads
* 2012-07-02: Week 3 Monday
** Adgenda
*** Fix GCStrategy so that I can walk the stack
*** Print roots with stalk walker
** Progress
*** InsertRootInitializer is seeing an alloca of a struct as a GC root
**** Since it assumes all roots are pointers, we're getting a cast failure
**** But why are we marking the alloca as a root in the first place?
**** In PerformDefaultLowering, llvm::Value::stripPointerCasts removes the getElementPtrInst which marks the field in the struct which is the root
**** For the moment I have added stripPointerCastsOnly which does not remove getElementPtrInsts, even with all-zero arguments
**** Need to decide whether to keep this or move elsewhere
*** Printing stack map
**** In C, because it's too painful to do in Rust
**** Next I need to figure out how to tell what function I'm in
* 2012-07-03: Week 3 Tuesday
** Adgenda
*** Map out stack (on paper)
*** How do I tell what function I am in?
*** Print roots for each function on stack
*** llvm::Value::stripPointerCastsOnly?
** Chat with Patrick (pcwalton)
*** Dump a sorted list of all possible return addresses for a function
**** Then we can binary search this list
*** But we need this in a global table so we can search it
**** We already have a crate-global table called the crate map (__crate_map)
**** Dump the stack map into the crate map, this can happen at compile time for static crates
**** Need to merge stack maps at runtime for dynamically linked crates
*** My fix for alloca GC roots (i.e. all roots must be pointers) sounds reasonable
** Progress
*** What is the format of the crate map? (TBD)
*** Imagine the following stack map ABI

_gc_metadata_somefn1:
   stack_map
_gc_metadata_somefn2:
   stack_map
_rust_crate_map_toplevel:
   ...
   num_safe_point_addrs
   { safe_point_addr, gc_metadata_ptr } * num_ret_addrs   // sorted by safe_point_addr

** Chat with Patrick (pcwalton) and Brian (brson)
*** Elliott: How can I put GC metadata in the crate map when the GC metadata is created as part of an LLVM optimization pass?
*** Patrick: Put an extern symbol in the crate map for the GC metadata and fill it in from the LLVM side.
*** (This means any safe point sorting or other fanciness will need to be done in the GCGenericPrinter.)
** Progress
*** Since crate map will only have a pointer, I can put it off and work on GCGenericPrinter instead
*** Stack map ABI Options
**** Sorted safe point => fn stack map

_gc_metadata_somefn1:
   stack_map
_gc_metadata_somefn2:
   stack_map
_gc_metadata_toplevel:
   num_safe_point_addrs
   { safe_point_addr, fn_info } * num_ret_addrs   // sorted by safe_point_addr
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

***** Still have to rescan safe points once you get to the stack map for a function
***** O(log(N) * k) where N is total number of safe points and k is safe points in specific function
**** Sorted safe point => safe point map => fn stack map

_gc_metadata_somefn1:
   stack_map contains:
_gc_metadata_somefn1_safepoint0:
   safe_point
_gc_metadata_somefn2:
   stack_map contains:
_gc_metadata_somefn2_safepoint0:
   safe_point

_gc_metadata_toplevel:
   num_safe_point_addrs
   { safe_point_addr, safe_point_info } * num_ret_addrs   // sorted by safe_point_addr
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

***** Forces double dereference to get to fn metadata
***** O(log(N) * 1 * 1)
***** Need symbols for every single safe point in module?
**** Sorted safe point (+ fn stack map pointer) => safe point map => fn stack map

_gc_metadata_somefn1:
   stack_map contains:
_gc_metadata_somefn1_safepoint0:
   safe_point
_gc_metadata_somefn2:
   stack_map contains:
_gc_metadata_somefn2_safepoint0:
   safe_point

_gc_metadata_toplevel:
   num_safe_point_addrs
   { safe_point_addr, safe_point_info, fn_info } * num_ret_addrs   // sorted by safe_point_addr
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

***** Single dereference to get to fn metadata, but safe point list is now 50% longer (bad for binary search?)
***** Still O(log(N) * 1 * 1)
**** But if you really wanted to avoid bloating the sorted safe point list, you could always use parallel arrays

_gc_metadata_somefn1:
   stack_map contains:
_gc_metadata_somefn1_safepoint0:
   safe_point
_gc_metadata_somefn2:
   stack_map contains:
_gc_metadata_somefn2_safepoint0:
   safe_point

_gc_metadata_toplevel:
   num_safe_point_addrs
   safe_point_addr * num_ret_addrs   // sorted by safe_point_addr
   safe_point_info * num_ret_addrs   // parallel array
   fn_info         * num_ret_addrs   // parallel array
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

**** Note that we already seem to have symbols for each safe point
* 2012-07-05: Week 3 Thursday
** Adgenda
*** Update GCGenericPrinter for new stack map ABI (with sorted index of safe points)
*** Print roots for each function on stack (finally?)
** Progress
*** Added module metadata to GenericGCMetadataPrinter to write out the safe point list, currently *unsorted*
*** Now I can print which safe point each return address belongs to
*** And I can walk the safe point metadata to get the list of stack roots, and find them on the stack
*** Next I need to figure out what I am pointing to
** Chat with Patrick (pcwalton) and Brian (brson)
*** Every non-trivial Rust type contains a header with type information (see "rust shape")
**** The C++ library should have a function to print out the type information ("upcall_log_type")
**** This code is currently being rewritten, but the replacement isn't ready yet
*** Each type will have its own destructor ("drop"); there will be a pointer to this type in the type header
**** These might be bare functions; if so, you will need to construct a closure (two words, according to Brian) to call it
**** Need to check what stack to run them on; if Rust, need Rust stack, if C, need C stack
* 2012-07-06: Week 3 Friday
** Adgenda
*** Look at shape code to find the drop method for each stack root
*** Figure out how to do register roots
*** Try to write c_fail so that we can test proper deallocation
*** Eventually sort stack roots so we can do a binary search
** Progress
*** Rust shape relevant files
**** rustc/middle/trans/shape.rs -- compiler-side generation of shapes
**** rt/rust_shape.h -- runtime-side interpretation of shapes
***** See shape_log_type
**** rt/rust_type.h -- layout of data
***** See rust_opaque_box and type_desc, et al
*** Looks like the type_desc contained in a box refers to the contained type, not the container type
**** Location of the pointer to the type_desc varies by type (e.g. box vs closure)
**** I'm guessing the compiler doesn't care because we normally have static type information available
**** It would be really nice to have a pointer to type_desc in the stack map
** Chat with Patrick (pcwalton)
*** Closures shouldn't be a problem, we'll root the env if we need to GC anything
*** Also, GC should only ever look at things in addrspace 1, since these may include e.g. closures, references to values owned elsewhere
** Progress
*** Moved more of the stack walking into rust
*** Bug where second box parameter on stack is never returned as a root
**** The second box here (a unique) does NOT show up

fn foo (x : i32) -> i32 {
    let y = @123;
    let z = ~123;
    let w = bar(x, y, z);
    baz(w, 456)
}

fn bar (x : i32, y : @i32, z : ~i32) -> i32 {
    my_fail();
    x + *y + *z+ 7
}

fn baz (x : i32, y : i32) -> i32 {
    x + y + 23
}

**** But this unique DOES show up?

fn foo (x : i32) -> i32 {
    let y = ~123;
    let w = bar(x, y);
    baz(w, 456)
}

fn bar (x : i32, y : ~i32) -> i32 {
    my_fail();
    x + *y + 7
}

fn baz (x : i32, y : i32) -> i32 {
    x + y + 23
}

**** This can be reproduced with all task-local boxes
* 2012-07-06: Week 3 Summary
** Fixed bug in rooting of first-field pointers in structs
** Emit per-module list of safe points
** Initial look at shape code
** Found second-parameter root bug
* 2012-07-09: Week 4 Monday
** Adgenda
*** Figure out how to drop a box given it's content type
*** Fix second box parameter bug
*** Figure out register roots
*** Eventually sort safe points so we can do a binary search
** Progress
*** I'm wondering if there is some generic drop box function I can call?
**** i.e. I want something to recursively call the drop glue function in the tydesc and then deallocate the box
**** Where do we generate the glue code?
***** rustc/middle/trans/base.rs: make_drop_glue and make_free_glue
*** What's the difference between drop and free?
*** Do these need to be called on the Rust stack or the C stack?
** Chat with Brian (brson)
*** Use box annihilator (rt/rust_box_annihilator.cpp) to deallocate a box if you don't know its type
** Progress
*** Now have a working deallocator on fail for exchange heap roots!
** Chat with Patrick (pcwalton)
*** Sounds like we can't really get much further without SelectionDAG, and we'll need it eventually, so might as well do it now
*** This might add issues with optimization
**** Just stick with -O0 for the moment, at least we can get to the point where we can do debug builds
**** We will need to validate every optimization one at a time to make sure it doesn't break things
*** Some initial work is on master (pcwalton/llvm)
**** See the most recent commit, "Beginnings of proper support without fake X86 instructions"
**** Not exactly the same, but this is hopefully a rough guide to how to get this done
*** Rough game plan
**** Add an SDNode for the new GC root intrinsic
**** Skip (a.k.a. "mark selected") for those nodes to avoid having to modify instruction selection tables
**** Manually lower them in the machine instruction emitter
***** This part should be identical to how we do this in the FastISel
**** Everything else should be handled by the existing GC work
*** Helpful tips
**** llc has some debug options to print the selection DAG
***** See --help-hidden, look for --view-*
** Adgenda (Revisited)
*** First pass on SelectionDAG for the new GC infrastructure
*** Eventually fix second box parameter bug
*** Eventually figure out register roots
*** Eventually sort safe points so we can do a binary search
** Progress
*** Do I need to make any changes for gcroot, or are my changes exclusively for gcregroot?
*** For that matter, do we use gcregroot that heavily in the first place?
**** Experiment: Turn off -fast-isel-abort, and make sure optimization is off, and see how many tests pass.
***** As long as we don't actually use gcregroot, we're fine. If we do, then we'll abort in SelectionDAG.
***** ./configure --disable-manage-submodules --prefix=$HOME/install --disable-optimize
***** make -j8 install && make -k RUSTFLAGS="--gc -Z no-landing-pads" check &> check-with-gc.log
* 2012-07-10: Week 4 Tuesday
** Meetings are in CYA at 9am on Tuesdays
** Adgenda
*** Check how far we can get without -fast-isel-abort
*** First pass on SelectionDAG for the new GC infrastructure
*** Eventually fix second box parameter bug
*** Eventually figure out register roots
*** Eventually sort safe points so we can do a binary search
** Progress
*** Looks like we can get away with -fast-isel-abort off, since we don't generate gcregroot most of the time at -O0
**** > 90% of run-passes tests compile, and most of those pass
**** A little hard to get exact numbers because one test is freezing
***** Brian says I can add `// xfail-test` to the top of tests to skip them
***** Also run make check with RUST_THREADS=1 to get the test runner to run in a single thread
***** Looks like the frozen test is unwind-resources
***** 748 tests passed, 11 failed, 1 froze up
***** That means 98.4% of run-passes tests passed!
***** Of those that fail, 8 have a gcregroot, 1 crashes in Lower GC Instructions pass, 1 failed because of missing landing pads, 1 failed because I leak memory, 1 failed in unicode (?)
**** Rustc itself has enough instances of gcregroot to stop us from compiling with GC on
** Chat with Patrick (pcwalton) and Brian (brson)
*** Now would be a good time to move fail to rust (and punt on SelectionDAG for the moment)
*** While we are at it, let's convert all the upcalls into rust
*** Add an attribute to the compiler, say #[upcall("fail")] to mark each fn
*** At the start of trans, walk every function to search for the upcall attributes, and stuff their names into a table
**** Patrick may have a function ("hpath"), which is a part of resolve3, which already does this
*** Then when we trans upcalls, make them normal rust calls instead of C calls
*** Alternatively, (as a start) we could hard code function names in trans (fail -> core::upcall::fail, etc.)
** Adgenda (Revisited)
*** Switch upcalls to rust
*** Everything else
** Progress
*** Start by wrapping rust upcalls around existing C upcalls in rt/rust_upcall.cpp
*** #[rust_stack] ensure we call the native function on the rust stack rather than on the C stack
*** Hitting an LLVM assertion about a type cast conflict.
**** Rename the function inside `extern mod rustrt { ... }` fixes the issue, but then I obviously can't link
**** Renaming the args doesn't fix it
**** Best guess is that we're declaring upcall_fail somewhere else, and the type declarations don't match
**** I'm too tired of dealing with this, I'll just call rust_task_fail and be done with it
** Chat with Brian (brson)
*** trans_crate is entry point for compiling a file
*** each_path (need to pull incoming to get resolve3) to walk external crates
*** visit_crate (libsyntax/visit.rs) to walk local crate
*** check attributes with libsyntax/attr.rs
*** build a table and stuff it into the crate context
** Progress
*** Added a rust_upcalls type which is intended to replace upcalls
*** Added gather_rust_upcalls to fill rust_upcalls from the crate AST
*** Walk all functions in crate, check attrs for each one, match against upcall(*)
* 2012-07-11: Week 4 Wednesday
** Adgenda
*** Emit upcalls in trans
*** Gather upcalls from external crates
*** Convert other upcalls
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Eventually fix second box parameter bug
**** Eventually figure out register roots
**** Eventually sort safe points so we can do a binary search
** Chat with Patrick (pcwalton)
*** Patrick thinks that there should be some sort of map from def_id's to ValueRef's
*** You'll need an extra level of indirection to get to the def_id's from node_id's though (Elliott: Why?)
** Progress
*** Some helpful types and functions
**** type node_id = int;
**** type def_id = {crate: crate_num, node: node_id};
**** const local_crate: crate_num = 0;
**** item_vals: int_hash<ValueRef>() -- looks like a map from node_id's to ValueRef's
**** fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef -- seem to build up the item_vals map lazily
*** It works. It's hacky. But I'm done with it.
**** I'm walking the local and external crates seperately.
**** External crates don't have attributes (they never get serialized) so we just hard code the names.
**** In core::upcall, if I try to use upcall_fail as a native function, I get conflicts with autogenerated wrappers, so I created an alias to make it work.
*** TODO: Rename 'upcall' to 'rt'.
* 2012-07-12: Week 4 Thursday
** Adgenda
*** Make all tests pass
*** Rename 'upcall' to 'rt'
*** Rebase onto incoming (once incoming stops burning, that is), and push
*** Everything else
**** Try out the GC (e.g. add it to the new fail upcall) and see if it crashes anything
**** First pass on SelectionDAG for the new GC infrastructure
**** Eventually fix second box parameter bug
**** Eventually figure out register roots
**** Eventually sort safe points so we can do a binary search
** Progress
*** Only one tests fails at the moment, module_polymorphism
**** The test doesn't link core because it defines modules with the same names as some in core
**** But it looks like it doesn't really have any reason for defining those exact names, so can fix by just renaming them
*** All tests pass, waiting for incoming to stop burning before rebasing
*** Sent pull request anyway, even though tests won't pass yet
*** Pop off the stack and go back to trying out the new GC
*** GC won't really work in general until:
**** Name each module's GC metadata after itself rather than _gc_metadata_toplevel
**** Copy pointer to GC metadata into crate map
**** Figure out how to get at the crate map inside libcore
* 2012-07-13: Week 4 Friday
** Adgenda
*** Stuff GC metadata into crate map
*** Get GC metadata out of crate map inside GC runtime
*** Move upcall_malloc over to rust so you have an extra place to test the GC
*** Run a bunch of tests to see if we can make things crash
*** Cleanup for rust runtime calls patch
**** Make rust_upcall_fail call upcall_fail so that we can break on upcall_fail in gdb
**** Fix indentation in rust_upcall_fail
**** Uncomment #[cfg(notest)] in core.rc
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Sort safe points so we can do a binary search
** Progress
*** Somehow, combining the rust runtime call patch with the GC patch causes a failure in trans_rtcall
**** Each patch works on its own
**** My best guess is that in trans_rtcall I'm passing an invalid node_id to lval_static_fn, which then seems to be picking up bogus type info
**** Trying lval_static_fn_inner instead
**** Looks like it works, passes tests
*** Need to bug Patrick or Brian to actually look at my pull request next week
** Next time
*** Check that GC metadata gets into crate map properly
*** Get GC metadata out of crate map inside GC runtime
*** Move upcall_malloc over to rust so you have an extra place to test the GC
*** Run a bunch of tests to see if we can make things crash
*** Cleanup for rust runtime calls patch
**** Uncomment #[cfg(notest)] in core.rc
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Sort safe points so we can do a binary search
* 2012-07-13: Week 4 Summary
** Added interface to box annihilator
** Initial working version of cleanup (intended to be called on failure)
** Is now a good time to work on SelectionDAG?
** Turns out we don't need FastISel most of the time after all, as long as we compile with -O0
** Initial working version of fail upcall in rust (now 'rtcall')
* 2012-07-16: Week 5 Monday
** Adgenda
*** Check that GC metadata gets into crate map properly
*** Get GC metadata out of crate map inside GC runtime
*** Move upcall_malloc over to rust so you have an extra place to test the GC
*** Run a bunch of tests to see if we can make things crash
*** Read GC literature
**** Especially the LuaJIT GC summary http://wiki.luajit.org/New-Garbage-Collector
*** Cleanup for rust runtime calls patch
**** Uncomment #[cfg(notest)] in core.rc
***** Note: I can't actually seem to do this yet. I'm not sure why Brian's (brson) patch isn't in the snapshot.
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Sort safe points so we can do a binary search
** Progress
*** Module metadata is now getting named properly (e.g. "_gc_module_metadata_NAME")
*** bstrie on IRC doesn't think we have any way to get at the crate map from rust code right now
*** Need to add a C++ runtime function to return the toplevel crate map. I'll walk the crate map inside Rust code.
*** This is getting strange. The crate map is used by the logging code and I'm not at all confident that my changes won't mess something up.
*** Plan with crate map:
**** Each module emits a _crate_map_* which links to its _gc_module_metdata_*
**** Each _crate_map_* gets recursively linked into the _crate_map_toplevel
**** At startup, rust_start will call <my GC startup function> to walk the crate map
***** For each module with a _gc_module_metadata, append the list of safe points onto some large list
***** Sort the list and stuff it into a global variable
**** Return the global list with some runtime function
*** Alternative to crate map?
**** Each module will need a GC metadata boolean flag so rustc knows whether to expect it to have a _gc_module_metadata_* or not
**** In rustc, when producing a binary, loop through all crates and link their _gc_module_metadata_* 's into a big list _gc_modules
**** In rust_start, loop through all of the modules and sort their safepoints. Stuff the result into some sort of a global variable.
**** Return the global variable inside some runtime function
*** I'm going with the crate map for now, since I'm not sure I want to deal with module metadata
*** Refactored crate map support from rt/rust_log.cpp to rt/rust_crate_map.cpp
*** Added rt/rust_gc_metadata.cpp to walk and sort safe points
*** It almost works but I forgot to put the number of safe points at the start of my vector.
* 2012-07-17: Week 5 Tuesday
** Adgenda
*** Move upcall_malloc and upcall_free over to rust so we have more places to test the GC
*** Run a bunch of tests to see if we can make things crash / if data is being deallocated properly on failure
**** I think we might have a problem with the current scheme for dropping uniques on failure
**** The GC is too smart and (in some cases, like explicit failure) knows that that data isn't live when we hit the rt::rt_fail call
**** So we don't see it as live inside the GC
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** Upcall free is working
*** Upcall malloc is providing some opposition
**** Getting the return value out of a function seems to require an alloca and a load after the call returns
**** Plus, I'm creating some sort of bogus basic block, which I'm having a hard time even dumping so I can see what is wrong
*** The problem is that malloc_* all return ValueRef's, not block's
**** i.e. The calling code assumes the ValueRef returned is in the same block as it was hold before issuing a malloc
**** But when I invoke a Rust function, it might not be (because of landing pads and unwind branching)
*** Shoot, it's still failing. What now?
*** How on earth did we manage to get to this state?

The offending function. Note the br instruction at the *start* of the return BB.

define void @_ZN4task7builder17_c1a43322f22768d63_03E(%"enum task::builder[#0]"*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*) uwtable {
static_allocas:
  %2 = alloca { void ({ void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*, { void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }
  %3 = alloca i8*
  store i8* null, i8** %3

load_env:                                         ; No predecessors!

return:                                           ; No predecessors!
                                                  ; No predecessors!
  br label %8
  %5 = getelementptr inbounds { void ({ void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*, { void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }* %2, i32 0, i32 0
  store void ({ void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*, { void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*)* @_ZN4task7builder4anonE, void ({ void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*, { void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*)** %5
  %6 = getelementptr inbounds { void ({ void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*, { void (i1*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }*)*, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* }* %2, i32 0, i32 1
  %7 = bitcast { i32, %tydesc*, i1*, i1*, {} }* %12 to { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)*
  store { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* %7, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)** %6

; <label>:8                                       ; preds = %4
  call void @_ZN2rt9rt_malloc17_32adc2dfc29da2a43_03E(i8** %3, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, i8* bitcast (%tydesc* @tydesc497 to i8*), i32 0)
  br label %9

; <label>:9                                       ; preds = %8
  %10 = load i8** %3
  %11 = bitcast i8* %10 to { i32, %tydesc*, i8*, i8*, {} } addrspace(1)*
  %12 = bitcast { i32, %tydesc*, i8*, i8*, {} } addrspace(1)* %11 to { i32, %tydesc*, i1*, i1*, {} }*
}

What I think might be the backtrace for the malloc call preceding the failure. Not completely sure because gdb isn't exactly the most usable tool here.

#0  0xb6143450 in middle::trans::base::malloc_raw::_f74abf816eaa5193::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#1  0xb629a85c in middle::trans::closure::allocate_cbox::_fddc3cda26aa0962::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#2  0xb629b1ed in middle::trans::closure::store_environment::_3a87aaf9eea043a3::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#3  0xb629deac in middle::trans::closure::build_closure::_4edfa8c550a2cf60::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#4  0xb62a3d63 in middle::trans::closure::trans_expr_fn::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#5  0xb61d4711 in middle::trans::closure::trans_expr_fn::_1ec07520dc7a96c9::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#6  0xb61f83d4 in middle::trans::base::trans_expr::unrooted::_2953c9b58c9ebada::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#7  0xb6185f89 in middle::trans::base::trans_expr::_2953c9b58c9ebada::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#8  0xb61818ef in middle::trans::base::trans_expr_save_in::_8d786287e9f52495::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#9  0xb6208f2d in middle::trans::base::init_local::_c3dca81c1d809a21::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#10 0xb620afe0 in middle::trans::base::trans_stmt::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#11 0xb6113c38 in vec::each5431::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#12 0xb6113abb in vec::unpack_slice5432::_b0dc179760ede46f::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#13 0xb6113995 in vec::each5431::_debf995279d11c60::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#14 0xb620ae79 in middle::trans::base::trans_stmt::_808d4b78e2ec2ec9::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#15 0xb62118bb in middle::trans::base::trans_block::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#16 0xb6113c38 in vec::each5431::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#17 0xb6113abb in vec::unpack_slice5432::_b0dc179760ede46f::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#18 0xb6113995 in vec::each5431::_debf995279d11c60::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#19 0xb6198782 in middle::trans::base::trans_block::_e796e910a1bf5b22::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#20 0xb621dd87 in middle::trans::base::trans_closure::_ec3b6a8ffe11c15e::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#21 0xb61af41d in middle::trans::base::trans_fn::_c481c6536648532a::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#22 0xb61c0158 in middle::trans::base::trans_item::_1ffb4147b7d0d1c9::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#23 0xb622a2f3 in middle::trans::base::trans_mod::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#24 0xb6113c38 in vec::each5431::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#25 0xb6113abb in vec::unpack_slice5432::_b0dc179760ede46f::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#26 0xb6113995 in vec::each5431::_debf995279d11c60::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#27 0xb6229552 in middle::trans::base::trans_mod::_97f1d8e744bd5ec3::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#28 0xb61c0324 in middle::trans::base::trans_item::_1ffb4147b7d0d1c9::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#29 0xb69f13b4 in __morestack () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#30 0xb622a2f3 in middle::trans::base::trans_mod::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#31 0xb6113c38 in vec::each5431::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#32 0xb6113abb in vec::unpack_slice5432::_b0dc179760ede46f::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#33 0xb6113995 in vec::each5431::_debf995279d11c60::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#34 0xb6229552 in middle::trans::base::trans_mod::_97f1d8e744bd5ec3::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#35 0xb625db34 in middle::trans::base::trans_crate::_ca7290f62280ebb2::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#36 0xb69b21b9 in driver::driver::compile_upto::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#37 0xb69b1971 in driver::driver::time25563::_c5c7ad722b971b2a::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#38 0xb69ac250 in driver::driver::compile_upto::_b9dbdc8c2a87d3af::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#39 0xb69f13b4 in __morestack () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#40 0xb69b29a2 in driver::driver::compile_input::_f76e3b45dfe4c695::_03 () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.3.so
#41 0x08054d6e in run_compiler::_45ed1c7bbe80da16::_00 ()
#42 0x0806aa5c in __morestack ()
#43 0x0806a6e5 in main::anon ()
#44 0x0806aa5c in __morestack ()
#45 0x0806471d in monitor::anon ()
#46 0x08062a6f in task::try588::anon ()
#47 0xb7b8b8ea in task::spawn_raw::make_child_wrapper::anon () from /home/elliottslaughter/rust2/i686-unknown-linux-gnu/stage1/bin/../lib/libcore-d27e4777a53c3e50-0.3.so
#48 0xb5f4c081 in task_start_wrapper (a=0xb4203cec) at /home/elliottslaughter/rust2/src/rt/rust_task.cpp:178
#49 0x00000000 in ?? ()

*** Looks like it's passing through store_environment, which indirectly calls malloc
**** But as far as I can tell, at least at the beginning of that function, nothing has been messed up yet
*** Best guess is someone is ignoring a bcx returned (and holding on to a ret_bcx value somewhere). It's probably upstream from store_environment.
* 2012-07-18: Week 5 Wednesday
** Adgenda
*** Fix bugs in trans emitting the malloc rtcall
*** Run a bunch of tests to see if we can make things crash / if data is being deallocated properly on failure
**** I think we might have a problem with the current scheme for dropping uniques on failure
**** The GC is too smart and (in some cases, like explicit failure) knows that that data isn't live when we hit the rt::rt_fail call
**** So we don't see it as live inside the GC
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Chat with Patrick (pcwalton)
*** Regarding memory leaks on cleanup of failed tasks
**** Patrick thinks we should be emitting a free call for the unique pointer, so it ought to be live
**** Trans might not be doing this currently because of the assumption that landing pads with deal with cleanup
**** See trans_cleanup to emit free calls unconditionally
**** Note: Dead code warnings occur before trans runs, so that shouldn't be an issue
*** Regarding resources
**** If we want to use the stack walker to cleanup the resources of failed tasks, things will get nasty
**** These aren't pointers, they're allocated directly on the stack, so we don't have the convenient assumption that everything is a pointer to a box
**** Two options:
***** Emit a tydesc pointer with every GC root
***** Emit a destructor pointer with every GC root
** Progress
*** Fixed the malloc rtcall
**** trans_expr_fn was misbehaving and not updating its bcx properly
*** That pull request should (finally) be ready to go now
**** https://github.com/mozilla/rust/pull/2884
*** Now the LLVM GC pass has issues with my malloc rtcalls
**** With all optimizations on, the failing function (task::run) has 400 basic blocks
***** LLVM is doing a LOT of inlining
**** Trying to find a configuration which allows me to get decent debug info out
***** Looks like the way to go is rustc optimization off, llvm optimization on
***** Although note that it fails on a different function (run::with_envp) than before
***** But it still has 163 basic blocks
* 2012-07-19: Week 5 Thursday
** Adgenda
*** Fix bug in LLVM Live IR Variables pass when using rust rtcall for malloc
*** Run a bunch of tests to see if we can make things crash / if data is being deallocated properly on failure
**** I think we might have a problem with the current scheme for dropping uniques on failure
**** The GC is too smart and (in some cases, like explicit failure) knows that that data isn't live when we hit the rt::rt_fail call
**** So we don't see it as live inside the GC
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Chat with Patrick (pcwalton)
*** Options for resources/destructors on the stack
**** Use metadata
***** Emit the type_desc pointer as the metadata
***** Requires that gcregroot support metadata
****** Otherwise GC'd values (at least ones with metadata) will be stuck in memory and we'll lose performance
***** Forces us to emit gcroot in rustc rather than use automatic rooting
**** Store a shadow pointer to the resource on the stack
***** Now we have two pointers for each resource
***** Requires resources to be self-describing, which they probably are not currently
**** Use different addrspaces for each type of destructor
***** Possible collisions between addrspaces from different modules
**** Create a new iface fast_drop which requires that the type is a pointer to a self-describing type
***** And you can only GC types which implement fast_drop
***** Requires a user-facing change to the language, kind of clunky
*** Investigate the following
**** Does gcregroot support metadata?
**** Do we every lower gcroot into gcregroot automatically?
***** Elliott: Presumably this would be in mem2reg, right?
** Progress
*** Everything in the LLVM Live IR Variables pass seems to be working fine (except for the debug printing)
*** Each individual piece seems to be doing exactly what it is supposed to be doing
**** DFS ordering works, topo sort works, back edges are labeled correctly, etc
*** But we're still violating the "Theorem 3" assertion
*** Patrick says this algorithm came from a paper (and sent me the link)
*** Patrick says the paper was a little unclear about the toposort bit, so that might be part of the problem
*** Need to read this paper and figure out what Theorem 3 is supposed to mean
* 2012-07-20: Week 5 Friday
** Adgenda
*** Fix bug in LLVM Live IR Variables pass when using rust rtcall for malloc
**** Read paper to figure out whether the algorithm is wrong or the data is wrong
***** http://hal.archives-ouvertes.fr/docs/00/19/22/19/PDF/fast_liveness.pdf
*** Run a bunch of tests to see if we can make things crash / if data is being deallocated properly on failure
**** I think we might have a problem with the current scheme for dropping uniques on failure
**** The GC is too smart and (in some cases, like explicit failure) knows that that data isn't live when we hit the rt::rt_fail call
**** So we don't see it as live inside the GC
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** Paper's definition of Reducible Control Flow seems to be violated by the failing function
**** I'm trying to run the LoopSimplify pass to see if I can avoid generating this code
***** But I have run it manually, because the PassManager dependency manager doesn't know how to order transformations properly
***** And even when I run it manually, it's ether not having any effect, or it's being blown away by something else
**** I think rustc is actually the wrong level to run this at. Maybe GCStrategy?
**** No, see instead TargetPassConfig::addIRPasses in llvm/lib/CodeGen/Passes.cpp
**** I've got enough debug info to be sure LoopSimplify is running before LiveIRVariables, but it's still crashing
***** And the PassManager *still* isn't smart enough to figure out that LoopSimplify isn't being invalidated before running LiveIRVariables
*** Does this 'bad' code come from rustc or an llvm optimization pass?
**** If it comes from rustc, could we fix the problem by turning off landing pads?
**** Without optimization on, the offending function is _ZN3run13with_envp19964anonE16
*** When you invoke a function inside a landing pad which also requires a landing pad, we use the landing pad we're already in
**** Doh!
**** To compile without landing pads: RUSTFLAGS='-Z no-landing-pads' make -j8
**** Only problem is you can't use this with the existing stage0 compiler, so do a regular build first (until it fails), and then switch over to no landing pads
**** Might want to push the no-landing-pads patch now that it actually matters...
*** The no-landing-pad build isn't going so hot
**** Failing at stage3 in libcore (out of stack space)
**** Can't get gdb to break at any of my upcall_fail, rt::rt_fail, etc. breakpoints
**** Trying unoptimized build with gdb
**** Can't seem to get backtrace out of gdb even in unoptimized build
**** Trying RUSTFLAGS='-Z no-landing-pads' RUST_LOG=rustc=0,::rt::backtrace make
**** gc::gc is in the backtrace of the infinite loop
**** Trying without calling into gc from malloc and free
**** IT COMPILES!!!!
*** Summary: LiveIRVariables can't handle self-referential landing pads (caused by issuing calls to Rust functions inside landing pads), and the GC causes an infinitely loop when called from exchange_malloc
*** Is GC actually allocating memory?
**** Maybe calling #fmt isn't such a great idea....
**** Yup, GC is fine as long as we don't call #fmt
**** io::stdout().write([<bytes>]) works as an alternative
** Next time
*** Cherry-pick no-landing-pads into a branch and issue a pull request
*** Ask Patrick about the complexity of making landing-pads with Rust calls not be self-referential
**** Would it work at all? Do C++ exceptions support throwing an exception while you're handling an exception?
*** Actually finally test the GC on the test suite
* 2012-07-21: Week 5 Summary
** Fix per-module metadata
** Initial working version of GC metadata runtime calls
** Initial working version of malloc and free upcalls in rust
** Encountered reducible CFG requirement of LiveIRVariables pass and self-referential landing pads issue in free rtcalls
* 2012-07-23: Week 6 Monday
** Adgenda
*** Actually finally test the GC on the test suite, or continue to fix bugs if it doesn't work as expected
*** Cherry-pick no-landing-pads into a branch and issue a pull request
*** Check the debug output of LoopSimplify on the code that fails LiveIRVariables to see why LoopSimplify can't handle it
*** Ask Patrick about the complexity of making landing-pads with Rust calls not be self-referential
**** Would it work at all? Do C++ exceptions support throwing an exception while you're handling an exception?
*** Bug Graydon to get form to sign for contributor access so I can assign issue to myself
**** https://github.com/mozilla/rust/issues/2997
**** https://github.com/mozilla/rust/issues/2861
**** https://github.com/mozilla/rust/issues/2232
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** Change rt::rt_fail's return type from 'nil' to '!' ? (See https://github.com/mozilla/rust/issues/2232)
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Chat with Patrick (pcwalton)
*** I should contact Chris Lattner <clattner@apple.com> <sabre@nondot.org> to ask about the defficiencies in the Liveness algorithm
*** Specifically, because the algorithm can't dependably handle all the control flow graphs that LLVM considers valid, should we really be using this algorithm?
*** Or should we be massaging the graph to try to have the best chance of making the algorithm work?
**** And what if this doesn't work?
**** E.g. does -loop-simplify understand invoke instructions?
*** Review of options for collecting resources:
**** Addrspace number per type:
***** Increase the size of the addrspace so we have 2**32 or whatever possible addrspaces
***** Emit a per-module map from addrspaces to typedescs
***** Emit in each function a pointer to the per-module type map
***** Note that for word-sized resources, we'll have to cast it to a pointer so that it can have an addrspace
***** Possible pitfall is that LLVM may optimize away the pointers?
**** Add metadata to gcregroot:
***** Emit gcroots in trans with typedescs as metadata
***** Emit metadata with safe points in the GC printer
***** Possible pitfall is that gcregroot may not support metadata
****** Patrick is worried that even if we add it, the metadata may get blown away by LLVM optimizations, or that pointers might have strange things done to them, etc.
** Progress
*** Patrick pushed rust runtime calls to incoming
**** Then incoming broke because I forgot to edit rustrt.def.in
**** Then I fixed it
**** Yay
*** Made issue #2997 for tracing GC
*** Added a pull request for turning off landing pads
*** About irreducible CFG's and nested exception handling
**** Can rt::rt_free fail?
**** Suppose it does, and suppose C++ (somehow) supports nested exception handlers.
**** Then we'll re-enter the landing pad at the top, and try to call free again. And presumably it will fail.
**** And we'll be in an infine loop.
**** But even if we had a separate landing pad, it's not clear that we'd make any useful progress anyway.
**** And I'm not sure C++ supports nested exceptions properly anyway.
*** About LoopSimplify's failure to make the landing pad mess reducible
**** Maybe LoopSimplify isn't running because the loop pass infrastructure doesn't understand invoke-based loops
**** Confirmed. LoopSimplify isn't running at all, because we're using invoke to construct the loop, rather than br.
*** Note: Nested exception handling *does not* work
**** http://llvm.org/docs/ExceptionHandling.html#cleanups
**** "Do not allow a new exception to propagate out of the execution of a cleanup. This can corrupt the internal state of the unwinder."
*** Investigate: Is there some way we can know (in trans) when we are in a landing pad? If so, we could avoid emitting invoke instructions.
**** Each basic block has a parent, walk up until we hit a landing pad or root.
* 2012-07-24: Week 6 Tuesday
** Adgenda
*** Actually finally test the GC on the test suite, or continue to fix bugs if it doesn't work as expected
*** Assign bugs to myself once I get contributer access
**** https://github.com/mozilla/rust/issues/2997
**** https://github.com/mozilla/rust/issues/2861
**** https://github.com/mozilla/rust/issues/2232
*** Emit root metadata (or addrspace) so we know how to drop resources
*** Keep roots live long enough to outlive fail
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** Change rt::rt_fail's return type from 'nil' to '!' ? (See https://github.com/mozilla/rust/issues/2232)
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** Fixed emitting invoke instructions inside landing pads
**** Issued pull request, graydon merged into incoming
*** Testing GC
**** Added gc() call to rt::rt_malloc and rt::rt_exchange_malloc
**** Turned off drop_uniques() call in rt::rt_fail
**** Compiled without optimization, with --gc enabled, with landing-pads-on

git fetch &&
git reset --hard origin/unique-ptrs &&
#./configure --prefix=$(pwd)/install --disable-optimize &&
(RUSTFLAGS='-O' make -j8) &&
make check -k 2>&1 | tee tests.log

**** Results: Passes all tests except one in run-passes and a segfault in stdtest!
***** The failing test is not obviously my fault. Something about UTF8, and I'm pretty sure I've seen this test fail before.
****** src/test/run-pass/utf8_idents.rs
****** Looks like a floating point imprecision error (using exact equality instead of subtract/abs/epsilon)
****** Trying a tweak to see if that fixes the test
****** Fixed, made a pull request
***** But stdtest is still segfaulting
****** In stdtest, failing test is uv_global_loop::test::test_gl_uv_global_loop_high_level_global_timer
*** Graydon is going to rebase LLVM, so be prepared for breakage
*** Patrick was right about gcregroot not including a metadata pointer
**** Need to evaluate whether or not metadata or addrspaces is the easier route
*** Graydon noticed upstream LLVM has added a pass called LiveRegMatrixPass
**** It's probably unrelated, but might as well check it out anyway
**** Looks like it's for register allocation, not liveness
* 2012-07-25: Week 6 Wednesday
** Adgenda
*** Fix build breakage in LiveIRVariables pass
*** Emit root metadata (or addrspace) so we know how to drop resources
*** Keep roots live long enough to outlive fail
*** Recurse on roots to get all live pointers
**** See https://github.com/mozilla/rust/issues/1498
*** Walk list of allocations to see what to free
*** Everything else
**** Change rt::rt_fail's return type from 'nil' to '!' ? (See https://github.com/mozilla/rust/issues/2232)
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** Need to fix build breakage on "Theorem 3"
**** This is the old version of my lpad check, which I think I might need
***** Patch 5f55c4b

     // Avoid using invoke if we are already inside a landing pad.
     let landing_pad = alt bcx.kind {
       block_scope(inf) { inf.landing_pad }
       _ { none }
     };
     alt landing_pad {
       option::some(ancestor) {
         let mut cur = option::some(bcx);
         while option::is_some(cur) && option::get(cur).llbb != ancestor {
             cur = option::get(cur).parent
         }
         if option::is_some(cur) && option::get(cur).llbb == ancestor {
             ret false;
         }
       }
       _ { }
     }

***** Never mind, I can't even build core with this patch, even given the ordering fix
**** We're producing an irreducible CFG alright, but it's not with invoke instructions this time

digraph {
  0 -> 1
  10 -> 7
  1 -> 2
  1 -> 3
  2 -> 3[color = red];
  2 -> 10
  3 -> 4
  3 -> 6
  3 -> 8
  3 -> 9
  4 -> 5
  5 -> 1[color = red];
  6 -> 7
  8 -> 2
  9 -> 5
}

**** Pushed a temporary fix which xfails the offending tests
**** Need to revert xfails and figure out how to make liveness happy again
**** Looks like the bad CFG is coming out of the LLVM optimizer
***** Unoptimized build works fine, so we're producing reducible code initially
***** But somehow the optimizer is producing irreducible code
**** Patrick suggests going through the LLVM passes one by one (for this file) and print the CFG after each one, to figure out which one is producing the bad result
*** Also, LiveIRVariables is slow
**** Patrick says LiveIRVariables::computeReachableBackEdges is the slowest
**** In the worst case it is N^2 in the number of basic blocks, and in an unoptimized build we have a lot of basic blocks
**** We're using a DenseSet for BackEdges, which is apparently eating up time
**** Pushed some fixes to my tree
* 2012-07-26: Week 6 Thursday
** Adgenda
*** Write email to Chris Lattner about the liveness algorithm
*** Better fix for LiveIRVariables pass
**** Figure out what LLVM optimization is producing the bad code
*** Emit root metadata (or addrspace) so we know how to drop resources
*** Everything else
**** Keep roots live long enough to outlive fail
**** Recurse on roots to get all live pointers
***** See https://github.com/mozilla/rust/issues/1498
**** Walk list of allocations to see what to free
**** Change rt::rt_fail's return type from 'nil' to '!' ? (See https://github.com/mozilla/rust/issues/2232)
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** Draft email to Chris Lattner

Hi Chris,

I am working with Patrick (CC'd) on Rust's GC. I believe you referred Patrick to a fast liveness paper[1]. While implementing the paper for LLVM, we noticed issues with assumptions it made.

The paper assumes reducible control flow. To my knowledge, this property does not hold in general for LLVM. And specifically, LLVM optimizations may not preserve this property even for code which originally satisfied it.

In Rust, we ran into some cases where we produced reducible code initially, but where the LLVM optimizer caused control flow to become irreducible. I find this troubling because failures are almost entirely opaque to the compiler writer; predicting what (reducible) code from the compiler is being made irreducible in the optimizer is not easy. And simple tricks like running LoopSimplify before our liveness pass appear to be ineffective.

Is this the best algorithm for liveness in LLVM? Can we ensure the invariants required by the algorithm are maintained across optimizations? Or do we need to go a different route?

Thanks.

[1]: "Fast Liveness Checking for SSA-Form Programs", http://hal.archives-ouvertes.fr/docs/00/19/22/19/PDF/fast_liveness.pdf

**** Email sent
* 2012-07-27: Week 6 Friday
** Adgenda
*** Evaluate alternative liveness algorithms suggested by Andrew Trick
**** The paper cited by Andrew suggests two approaches
**** One is already used in LLVM's LiveVariables pass
**** A second one might be faster, but appears to be more complex
*** Emit root metadata (or addrspace) so we know how to drop resources
*** Everything else
**** Keep roots live long enough to outlive fail
**** Recurse on roots to get all live pointers
***** See https://github.com/mozilla/rust/issues/1498
**** Walk list of allocations to see what to free
**** Change rt::rt_fail's return type from 'nil' to '!' ? (See https://github.com/mozilla/rust/issues/2232)
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** I started moving LLVM's LiveVariables pass over to work on the IR
* 2012-07-27: Week 6 Summary
** Fixed self-referential landing pads
** Updated to latests LLVM
** Firefighting build breakage, problems go deeper than self-referential tests, temporarily xfailed troublesome tests
** Wrote to Christ Lattner about deficiencies in current LiveIRVariables approach
** Initial work on new liveness algorithm based on LLVM's LiveVariables pass
* First Half Summary
** Initial stack walker with deallocation of boxes working
** Upcalls moved to rust (fail, malloc, free)
** Fixed bugs in liveness, GC infrastructure
** Emit list of safe points in GC printer, and sort them on startup
** Biggest challanges to GC are rooting non-boxes (i.e. resources) and making SelectionDAG et al compatible with gcregroot
* 2012-07-30: Week 7 Monday
** Adgenda
*** Finish and debug port of LiveVariables pass to IR
*** Emit root metadata (or addrspace) so we know how to drop resources
**** Patrick is enthusiastic about the addrspace approach, although I am skeptical
*** Everything else
**** Keep roots live long enough to outlive fail
**** Recurse on roots to get all live pointers
***** See https://github.com/mozilla/rust/issues/1498
**** Walk list of allocations to see what to free
**** Change rt::rt_fail's return type from 'nil' to '!' ? (See https://github.com/mozilla/rust/issues/2232)
**** First pass on SelectionDAG for the new GC infrastructure
**** Fix second box parameter bug
**** Figure out register roots
**** Binary search on safe points
** Progress
*** Draft email to Andrew Trick <atrick@apple.com>, et al

When I last looked at it, the amount of machine-specific logic in LiveVariables obfuscated the algorithm behind the code. Now that I have had a chance to take another look, the algorithm doesn't look nearly so bad. I spent a day or so porting LiveVariables over to work on the IR, and seem to have a working version.

Thank you both for your help.

*** New LiveIRVariables builds rustc without crashing and passes all tests
**** Pushed to incoming
**** Burning on Windows, but hopefully transient
