* 2012-06-19: Notes to self
** FastISel
*** Rust doesn't call SelectionDAG or FastISel directly, but through an LLVM pass.
*** Some function is responsible for setting up the instruction selector (addISelToPass or somesuch).
*** Need to add fast-isel-abort parameter to this pass so the FastISel knows not to fall back to SelectionDAG.
*** Rust compilation happens in three phases:
**** Stage 0: Download binary from server.
**** Stage 1: Compile rustc with binary.
**** Stage 2: Compile rustc with itself.
**** Stage 3: Compile rustc with itself again to check stability.
*** If you swap in FastISel, then you might only be able to get through stage 1 (i.e. rustc might not be able to compile itself), but you should be able to still try some simple testcases.
*** See how many testcases you can do, then switch over to other stuff.
** Roadmap (as far as I can remember)
*** ISel
**** FastISel and fast-isel-abort
**** Merge work on FastISel
**** Finish work on SelectionDAG
*** Unwinding
*** ???
* 2012-06-20: Notes to self
** Still looking for the call that sets the ISel parameters
*** The rustc backend calls addPassesToEmitFile for codegen (rustllvm/RustWrapper.cpp)
**** ==> calls addPassesToGenerateCode
**** ==> sets TargetMachine::setFastISel and calls TargetPassConfig::addInstSelector (abstract method)
**** ==> X86PassConfig::addInstSelector ==> createX86ISelDag ==> new X86DAGToDAGISel
*** -fast-isel-abort is specified in SelectionDAGISel.cpp
**** SelectionDAGISel.cpp is an LLVM pass that takes -fast-isel-abort as a command line param
***** -fast-isel on the other hand is passed via the TargetMachine and PassConfig
**** SelectionDAGISel does NOT pass -fast-isel-abort to the TargetMachine when it creates the FastISel
**** SelectionDAGISel manually calls the FastISel when doing codegen
**** So it just aborts manually when FastISel fails to select all instructions for a block. (See lines 1140-1143.)
***** if (EnableFastISelAbort) llvm_unreachable(...);
*** Got -fast-isel-abort to work by hard-coding it in SelectionDAGISel.cpp

diff --git a/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp b/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp
index 2c149da..c0aaf13 100644
--- a/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp
+++ b/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp
@@ -54,6 +54,7 @@
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/ADT/Statistic.h"
 #include <algorithm>
+#include <cstdio>
 using namespace llvm;
 
 STATISTIC(NumFastIselFailures, "Number of instructions fast isel failed on");
@@ -340,6 +341,11 @@ bool SelectionDAGISel::runOnMachineFunction(MachineFunction &mf) {
   assert((!EnableFastISelAbort || TM.Options.EnableFastISel) &&
          "-fast-isel-abort requires -fast-isel");
 
+  if (TM.Options.EnableFastISel) EnableFastISelAbort = true; // Elliott
+  printf("Elliott: This is SelectionDAGISel.\n");
+  printf("Elliott: -fast-isel is %d.\n", TM.Options.EnableFastISel);
+  printf("Elliott: -fast-isel-abort is %d.\n", !!EnableFastISelAbort);
+
   const Function &Fn = *mf.getFunction();
   const TargetInstrInfo &TII = *TM.getInstrInfo();
   const TargetRegisterInfo &TRI = *TM.getRegisterInfo();

*** But FastISel can't compile any non-trivial program anyway, so it doesn't seem to help

$ cat test.rs
fn main () {
    io::println("hi");
}

$ rustc test.rs
Elliott: This is SelectionDAGISel.
Elliott: -fast-isel is 1.
Elliott: -fast-isel-abort is 1.
FastISel missed terminator:   invoke void @_ZN2io7println17_7bd51147c9de282c3_02E(i1* undef, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6)
          to label %7 unwind label %8
FastISel miss:   store { i8*, i32 } %9, { i8*, i32 }* %2
FastISel didn't select the entire block
UNREACHABLE executed at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:1149!
Stack dump:
0.	Running pass 'Function Pass Manager' on module 'test.rc'.
1.	Running pass 'X86 DAG->DAG Instruction Selection' on function '@_ZN4main17_f8ae15773a042ac13_00E'
Aborted (core dumped)

*** It can at least do basic arithmetic

$ cat test.rs
fn main () {
    let mut a = 5, b = 6;
    a += b;
    os::set_exit_status(a);
}

$ rustc test.rs
Elliott: This is SelectionDAGISel.
Elliott: -fast-isel is 1.
Elliott: -fast-isel-abort is 1.
[...]

$ ./test; echo $?
11

*** 37% of the tests pass in rust/src/test/run-pass
*** A lot of tests seem to be failing from store instructions
**** store { i8*, i32 } %9, { i8*, i32 }* %2
**** Looks like the unwind handler for a call, because this is preceded by

    ; <label>:4                                       ; preds = %3
      %5 = call i8* @upcall_str_new_uniq(i8* getelementptr inbounds ([3 x i8]* @str1, i32 0, i32 0), i32 2)
      %6 = bitcast i8* %5 to { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)*
      invoke void @_ZN2io7println17_7bd51147c9de282c3_02E(i1* undef, { i32, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6)
>>>>          to label %7 unwind label %8                                                           <<<< note unwind label

    ; <label>:7                                       ; preds = %4
      br label %14

    ; <label>:8                                       ; preds = %4
      %9 = landingpad { i8*, i32 } personality i32 ()* @upcall_rust_personality
              cleanup
      call void @upcall_reset_stack_limit()
>>>>  store { i8*, i32 } %9, { i8*, i32 }* %2                                                       <<<< error here
      br label %10

    ; <label>:10                                      ; preds = %8
      %11 = bitcast { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6 to i8*
>>>>  call void @glue_free3(i1* null, i1* null, %tydesc** null, i8* %11)                            <<<< clean up memory
      %12 = load { i8*, i32 }* %2
      resume { i8*, i32 } %12
    
    ; <label>:13                                      ; preds = %14
>>>>  br label %return                                                                              <<<< success return path

    ; <label>:14                                      ; preds = %7
      %15 = bitcast { i32, %tydesc*, i8*, i8*, { i32, i32, [0 x i8] } } addrspace(1)* %6 to i8*
      call void @glue_free3(i1* null, i1* null, %tydesc** null, i8* %15)
      br label %13

** Need to grill Patrick (pcwalton) again to figure out which of his branches I'm interested in
*** gc? (11 months old)
*** backpointers? (20 months old)
*** unique-imm? (10 months old)
*** Others don't look relevant.
* 2012-06-21: Notes to self
** Continued ISel hacking
*** Store instructions come from stack unwinding (get_landing_pad in rustc/middle/trans/base.rs)
**** invoke is an LLVM instruction which branches when an exception is hit
**** landingpad is an LLVM instruction which returns the exception data
**** resume is an LLVM instruction which resumes unwinding the stack
**** Some runtime functions interact with exception handling
***** upcall_reset_stack_limit / upcalls.reset_stack_limit -- for fiddling with the Rust stack
***** upcall_rust_personality / upcalls.rust_personality -- returns exception handler metadata
*** I replaced the failing store instruction with the following

  %v1 = extractvalue { i8*, i32 } %9, 0
  %v2 = extractvalue { i8*, i32 } %9, 1
  %p1 = getelementptr { i8*, i32 }* %2, i32 0, i32 0
  %p2 = getelementptr { i8*, i32 }* %2, i32 0, i32 1
  store i8* %v1, i8** %p1
  store i32 %v2, i32* %p2
; store { i8*, i32 } %9, { i8*, i32 }* %2

*** And now it fails on the landingpad instruction

%8 = landingpad { i8*, i32 } personality i32 ()* @upcall_rust_personality cleanup

*** I'm pretty sure there's no way to get around this one
* 2012-06-21: Chat with Patrick (pcwalton)
** Rust currently uses landing pads and DWARF C++ exception handlers to free unique pointers (~) (i.e. exchange heaps)
** But errors are non-recoverable anyway (try/catch only at task call boundaries), so we really don't need anything that fancy
** Walk the stack to find free unique pointers (~) and free them (and delete the landing pads)
** Patrick already has a branch with the GC changes necessary to start work on this
*** https://github.com/pcwalton/llvm/tree/noteroots-ir
*** But it only supports FastISel, so you're going to have to start there
*** (I'm still not sure I understand *what* these GC changes are exactly, but whatever)
** Initial step is to set up the basic stack walking and cleanup
*** Add gc "generic" (<== name of the gc he wrote) to functions
**** This should add stack maps to generated assembly for these functions
*** Simple test program

let x : ~int = 3; // Create a unique box with 3 in it
fail;             // Then crash and see what happens

* 2012-06-21: Notes to self
** Progress (or not)
*** Downloaded pcwalton's llvm branch
*** His branch had an issue with LLVMLinkModules being linked multiple times, but I think I fixed it (by deleting the rust copy, which didn't appear to be used anyway)
*** Rust build is crashing in Live IR Variables pass, which is something pcwalton added
**** Here's the backtrace

#0  0xb4be87a0 in llvm::Value::getValueID (this=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Value.h:228
#1  0xb4be8945 in llvm::Instruction::getOpcode (this=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Instruction.h:82
#2  0xb4be895b in llvm::Instruction::isTerminator (this=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Instruction.h:85
#3  0xb4be9261 in llvm::TerminatorInst::classof (I=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/InstrTypes.h:78
#4  0xb4bfc58c in llvm::isa_impl<llvm::TerminatorInst, llvm::Instruction>::doit (Val=...) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:50
#5  0xb4bf9057 in llvm::isa_impl_cl<llvm::TerminatorInst, llvm::Instruction*>::doit (Val=0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:68
#6  0xb4bf3ed4 in llvm::isa_impl_wrap<llvm::TerminatorInst, llvm::Instruction*, llvm::Instruction*>::doit (Val=@0xb40febdc: 0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:99
#7  0xb4bef425 in llvm::isa<llvm::TerminatorInst, llvm::Instruction*> (Val=@0xb40febdc: 0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:110
#8  0xb541b825 in llvm::dyn_cast<llvm::TerminatorInst, llvm::Instruction*> (Val=@0xb40febdc: 0x0) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:220
#9  0xb54e68eb in llvm::BasicBlock::getTerminator (this=0xb1ff7734) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/BasicBlock.cpp:122
#10 0xb4ca56e9 in llvm::succ_begin (BB=0xb1ff7734) at /home/elliottslaughter/rust/src/llvm/include/llvm/Support/CFG.h:227
#11 0xb50330f5 in llvm::LiveIRVariables::computeBackAndIncomingEdges (this=0xb1e81da8, F=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:92
#12 0xb5032e56 in llvm::LiveIRVariables::runOnFunction (this=0xb1e81da8, F=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:59
#13 0xb55e4514 in llvm::FPPassManager::runOnFunction (this=0xb3ccb810, F=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1479
#14 0xb55e46d0 in llvm::FPPassManager::runOnModule (this=0xb3ccb810, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1499
#15 0xb55e49ae in llvm::MPPassManager::runOnModule (this=0xb2ff4e18, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1553
#16 0xb55e4e58 in llvm::PassManagerImpl::run (this=0xb2e86858, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1636
#17 0xb55e4ff5 in llvm::PassManager::run (this=0xb2e52990, M=...) at /home/elliottslaughter/rust/src/llvm/lib/VMCore/PassManager.cpp:1665
#18 0xb4bcda09 in LLVMRustWriteOutputFile (PMR=0xb2e52990, M=0xb2eaf120, triple=0xb41037c0 "i686-unknown-linux-gnu",
    path=0xb212b820 "i686-unknown-linux-gnu/stage1/lib/rustc/i686-unknown-linux-gnu/lib/libcore.o", FileType=llvm::TargetMachine::CGFT_ObjectFile, OptLevel=llvm::CodeGenOpt::None,
    EnableSegmentedStacks=true) at /home/elliottslaughter/rust/src/rustllvm/RustWrapper.cpp:101
#19 0xb6cb7530 in LLVMRustWriteOutputFile__c_stack_shim () from /home/elliottslaughter/rust/i686-unknown-linux-gnu/stage1/bin/../lib/librustc-73389320c1332876-0.2.so
#20 0xb615190f in __morestack () from /home/elliottslaughter/rust/i686-unknown-linux-gnu/stage1/bin/../lib/librustrt.so

*** Yup, sounds like fun (or not)
* 2012-06-22: Notes to self
** Debugging Live IR Variables (llvm/lib/CodeGen/LiveIRVariables.cpp)
*** Crash computeBackAndIncomingEdges appears to come from having a BB with a null pointer in its instruction list
*** Noticed SmallVector<16> and SmallSet<16>, and function has more than 16 BBs
**** Tried 64 instead of 16, and crash was delayed for about 20 more functions
**** But the API claims it will allocate heap space when fixed stack space is used up, so how on earth does this matter?
**** Maybe there is some other memory corruption and I'm just avoiding it with extra padding?
**** Could it be inserting into the vector while iterating it?

for (SmallVector<BasicBlock *, 64>::iterator BBI = WorkList.begin();
                                             BBI != WorkList.end(); ++BBI) {
  // ...
  for (succ_iterator SI = succ_begin(*BBI),
                     SE = succ_end(*BBI); SI != SE; ++SI) {
     // ...

     WorkList.push_back(*SI);
  }
}

*** Crash moved down to computeReachableBackEdges (_ZN3int5range17_6b446dc7ab6447ad3_02E)
**** Assertion `t <= i && "Theorem 3 was violated!"' failed
**** Problem appears to be (at least partially) upstream of the assertion failure
*** Graphviz diagram for the block control flow

digraph _ZN3int5range17_6b446dc7ab6447ad3_02E {

bb0 -> bb1
bb1 -> bb2
bb2 -> bb3
bb3 -> bb4
bb4 -> bb5
bb4 -> bb9
bb5 -> bb6
bb6 -> bb7
bb7 -> bb8
bb7 -> bb11
bb8 -> bb9
bb9 -> bb10
bb11 -> bb12
bb12 -> bb4

}

*** Problems I found in the reachability algorithms
**** Take this all with a grain of salt because I'm still not sure how this is being used
**** computeBackAndIncomingEdges has an issue where it will find back edges in a DAG with no cycles
***** Changed BFS to DFS to allow me to track the path to the current node for cycle detection
**** computeTopologicalOrdering has an issue where it is ordering nodes incorrectly
***** Actually that problem is in computeBackAndIncomingEdges because the incoming counts are wrong (need to count edges from nodes we've already visited, but NOT if they're on the path to the current node)
*** Now the results look right for that function, but it's crashing later on (in a debug function???)
**** Backtrace

#0  0xb4f53adb in llvm::BitVector::find_first (this=0xb3299ef4) at /home/elliottslaughter/rust/src/llvm/include/llvm/ADT/BitVector.h:146
#1  0xb50353c6 in llvm::LiveIRVariables::isLiveIn (this=0xb21c0b68, V=..., BB=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:272
#2  0xb50358ce in llvm::LiveIRVariables::dump (this=0xb21c0b68, F=..., IncludeDead=false) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:351
#3  0xb5033fe4 in llvm::LiveIRVariables::runOnFunction (this=0xb21c0b68, F=...) at /home/elliottslaughter/rust/src/llvm/lib/CodeGen/LiveIRVariables.cpp:68

*** Turned off debugging, problem "solved"
*** Rustc now compiles itself!!!
*** (Virtual) Tomorrow (a.k.a. Monday): Cleanup patches to make rustc work with the new llvm, then move on to turning on GC on functions
* 2012-06-25: Notes to self
** First pass turning on GC "generic"
*** Rustc can't be compiled because SelectionDAG doesn't know what to do about gcregroot intrinsics, and FastISel can't handle other things (sdiv)
*** Maybe do proper command line parsing rather than mashing the value of -fast-isel-abort to true?
**** Hoping that the FastISel can handle the gcregroot intrinsics and leave everything else to the SelectionDAG
**** No, SelectionDAG still gets confused, even when delegating to FastISel
*** Maybe I could add a flag to rustc to enable GC "generic"?
**** I added a --gc flag to rustc to turn on GC. Moving along now.
*** Failed compile box.rs with GC: upcall_fail requires a landing pad

fn main() {
  let x = ~3;
  fail;
}

*** Potential ways forward?
**** Fix SelectDAG for new GC intrinsics
**** Rip out error handling and write the stack walker
*** Random questions
**** Does it really make any sense to mark unique pointers as GC roots? They're not going to be GC'd.
**** Does the existing "generic" GC generate any GC roots? Don't we need to generate those in rustc?
***** The GCStrategy appears to add GC roots itself.
**** Where is does the stack map go and what format do we generate it in? Does it contain any sort of type information?
***** See llvm/lib/CodeGen/AsmPrinter/GenericGCPrinter.cpp
***** Look for frametable at the end of the data section
**** What are the semantics of gcregroot? How will we access values in registers? Will we write the registers to the stack map? We can't actually safely run the GC without dumping these to memory anyway, right?
***** My best guess is the callee saves the registers before initiating any GC. Then the GC needs to know where those got put on the stack.
* 2012-06-26: Notes to self
** Adgenda
*** Find stack map and make sure it gets in the binary
*** Write stack walker for runtime
*** Delete C++ error handler and see if that lets me compile things (albeit with memory leaks)
*** Fix memory leaks by using stack walker to clean up unique pointers
** Progress
*** Stack map format (llvm/lib/CodeGen/AsmPrinter/GenericGCPrinter.cpp)

Symbol: '_gc_metadata' + mangled(fn_name)

struct function_metadata {
  .align(pointer)
  num_callee_saved_regs : i32
  num_safe_points       : i32

  // callee saved regs
  stack_offsets         : [i32 * num_callee_saved_regs]
  register              : [i8 * num_callee_saved_regs]

  // safe points
  .align(pointer)
  safe_point_name       : [sp_name * num_safe_points]
  safe_points_info      : [sp_info * num_safe_points]

  struct sp_name {
    safe_point_address    : pointer
    safe_point_symbol     : pointer
  }

  struct sp_info {
    .align(pointer)
    num_stack_roots     : i32
    num_reg_roots       : i32

    stack_root_offsets  : [i32 * num_stack_roots]
    reg_roots           : [i8 * num_reg_roots]
    address_space       : [i8 * (num_stack_roots + num_reg_roots)]
  }
}

*** To list symbols: objdump --syms <binary>
*** To get data section contents: objdump --full-contents --section=.data <binary>
** Chat with Patrick and Brian
*** Patrick gave me access to his llvm fork on github so I can push fixes to Live IR Variables
*** libcore currently contains a basic stack walker that just chases frame pointers
*** ./configure --disable-manage-submodules to stop rust from messing with your submodules
*** For error handling, add a -Z no-landing-pads flag to turn off landing pads
*** The new error handling will run on the rust stack without needing C++ exceptions
**** Instead of fail turning into a call to C++ upcall_fail(), it will call a rust function fail()
**** Then you'll walk the stack in rust code, clean everything up, and issue a context switch back into the scheduler
** New Adgenda
*** Try core::walk_stack (without GC, because this is a rust call)
*** Add flag to turn off landing pads
*** Use core::walk_stack to print GC roots (requires landing pads be off)
** Progress (again)
*** core::walk_stack doesn't actually work as advertised
**** frame_address intrinsic never calls closure
**** Name mangling is failing, causing the frame_address intrinsic and its wrapper to be called by the same name
***** Note: This is because internally trans inserts another wrapper for intrinsics (that is, we have *two* wrappers, and they have the same name)
**** Workaround is to rename frame_address wrapper in libcore/stackwalk.rs
**** Permanent solution is probably to fix intrinsic mangling in rustc/middle/trans/base.rs
**** Bailing for now, I have a workaround, so I'll let someone else fix this
* 2012-06-29: Notes to self
** Adgenda
*** Add flag to turn off landing pads
*** Use core::walk_stack to print GC roots (requires landing pads be off)
** Progress
*** Turning off landing pads
**** rustc/middle/trans/base.rs has a function needs_invoke which looks like the right place
**** It works!!! I got a memory leak!

$ cat unique-box.rs
fn main() {
  let x = ~3;
  fail;
}

$ rustc --gc -Z no-landing-pads unique-box.rs
unique-box.rs:2:6: 2:7 warning: unused variable: `x`
unique-box.rs:2   let x = ~3;
                      ^
$ ./unique-box
rust: upcall fail 'explicit failure', unique-box.rs:3
rust: domain main @0x9944ed0 root task failed
leaked memory in rust main loop (1 objects)
unique-box: /home/elliottslaughter/rust/src/rt/memory_region.cpp:172: memory_region::~memory_region(): Assertion `false' failed.
Aborted (core dumped)

*** Printing GC roots
**** GC lowering is crashing due to reinterpret_cast

rustc: /home/elliottslaughter/rust/src/llvm/include/llvm/Support/Casting.h:194: typename llvm::cast_retty<To, From>::ret_type llvm::cast(const Y&) [with X = llvm::PointerType, Y = llvm::Type*, typename llvm::cast_retty<To, From>::ret_type = llvm::PointerType*]: Assertion `isa<X>(Val) && "cast<Ty>() argument of incompatible type!"' failed.
Stack dump:
0.      Running pass 'Function Pass Manager' on module 'stack-test.rc'.
1.      Running pass 'Lower Garbage Collection Instructions' on function '@_ZN3bar4anonE'
Aborted (core dumped)

**** Removing the reinterpret_cast fixes the problem, but then I can't use the value
**** Looks like it's coming from LowerIntrinsics::InsertRootInitializers
***** Need to read that code, not sure what's going on
*** Also found a bug in LowerIntrinsics::PerformDefaultLowering
**** Loop iterator bounds getting mixed up
**** I hope this fixes the other problem, but I wouldn't bet on it
*** In other news, 80% of tests can be compiled with --gc -Z no-landing-pads
* 2012-07-02: Notes to self
** Adgenda
*** Fix GCStrategy so that I can walk the stack
*** Print roots with stalk walker
** Progress
*** InsertRootInitializer is seeing an alloca of a struct as a GC root
**** Since it assumes all roots are pointers, we're getting a cast failure
**** But why are we marking the alloca as a root in the first place?
**** In PerformDefaultLowering, llvm::Value::stripPointerCasts removes the getElementPtrInst which marks the field in the struct which is the root
**** For the moment I have added stripPointerCastsOnly which does not remove getElementPtrInsts, even with all-zero arguments
**** Need to decide whether to keep this or move elsewhere
*** Printing stack map
**** In C, because it's too painful to do in Rust
**** Next I need to figure out how to tell what function I'm in
* 2012-07-03: Notes to self
** Adgenda
*** Map out stack (on paper)
*** How do I tell what function I am in?
*** Print roots for each function on stack
*** llvm::Value::stripPointerCastsOnly?
** Chat with Patrick (pcwalton)
*** Dump a sorted list of all possible return addresses for a function
**** Then we can binary search this list
*** But we need this in a global table so we can search it
**** We already have a crate-global table called the crate map (__crate_map)
**** Dump the stack map into the crate map, this can happen at compile time for static crates
**** Need to merge stack maps at runtime for dynamically linked crates
*** My fix for alloca GC roots (i.e. all roots must be pointers) sounds reasonable
** Progress
*** What is the format of the crate map? (TBD)
*** Imagine the following stack map ABI

_gc_metadata_somefn1:
   stack_map
_gc_metadata_somefn2:
   stack_map
_rust_crate_map_toplevel:
   ...
   num_safe_point_addrs
   { safe_point_addr, gc_metadata_ptr } * num_ret_addrs   // sorted by safe_point_addr

** Chat with Patrick (pcwalton) and Brian (brson)
*** Elliott: How can I put GC metadata in the crate map when the GC metadata is created as part of an LLVM optimization pass?
*** Patrick: Put an extern symbol in the crate map for the GC metadata and fill it in from the LLVM side.
*** (This means any safe point sorting or other fanciness will need to be done in the GCGenericPrinter.)
** Progress
*** Since crate map will only have a pointer, I can put it off and work on GCGenericPrinter instead
*** Stack map ABI Options
**** Sorted safe point => fn stack map

_gc_metadata_somefn1:
   stack_map
_gc_metadata_somefn2:
   stack_map
_gc_metadata_toplevel:
   num_safe_point_addrs
   { safe_point_addr, fn_info } * num_ret_addrs   // sorted by safe_point_addr
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

***** Still have to rescan safe points once you get to the stack map for a function
***** O(log(N) * k) where N is total number of safe points and k is safe points in specific function
**** Sorted safe point => safe point map => fn stack map

_gc_metadata_somefn1:
   stack_map contains:
_gc_metadata_somefn1_safepoint0:
   safe_point
_gc_metadata_somefn2:
   stack_map contains:
_gc_metadata_somefn2_safepoint0:
   safe_point

_gc_metadata_toplevel:
   num_safe_point_addrs
   { safe_point_addr, safe_point_info } * num_ret_addrs   // sorted by safe_point_addr
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

***** Forces double dereference to get to fn metadata
***** O(log(N) * 1 * 1)
***** Need symbols for every single safe point in module?
**** Sorted safe point (+ fn stack map pointer) => safe point map => fn stack map

_gc_metadata_somefn1:
   stack_map contains:
_gc_metadata_somefn1_safepoint0:
   safe_point
_gc_metadata_somefn2:
   stack_map contains:
_gc_metadata_somefn2_safepoint0:
   safe_point

_gc_metadata_toplevel:
   num_safe_point_addrs
   { safe_point_addr, safe_point_info, fn_info } * num_ret_addrs   // sorted by safe_point_addr
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

***** Single dereference to get to fn metadata, but safe point list is now 50% longer (bad for binary search?)
***** Still O(log(N) * 1 * 1)
**** But if you really wanted to avoid bloating the sorted safe point list, you could always use parallel arrays

_gc_metadata_somefn1:
   stack_map contains:
_gc_metadata_somefn1_safepoint0:
   safe_point
_gc_metadata_somefn2:
   stack_map contains:
_gc_metadata_somefn2_safepoint0:
   safe_point

_gc_metadata_toplevel:
   num_safe_point_addrs
   safe_point_addr * num_ret_addrs   // sorted by safe_point_addr
   safe_point_info * num_ret_addrs   // parallel array
   fn_info         * num_ret_addrs   // parallel array
_rust_crate_map_toplevel:
   ...
   gc_metadata_toplevel_ptr

**** Note that we already seem to have symbols for each safe point
* 2012-07-05: Notes to self
** Adgenda
*** Update GCGenericPrinter for new stack map ABI (with sorted index of safe points)
*** Print roots for each function on stack (finally?)
** Progress
*** Added module metadata to GenericGCMetadataPrinter to write out the safe point list, currently *unsorted*
*** Now I can print which safe point each return address belongs to
**** Still some confusion about exactly which stack entries are what and which return address refers to which stack frame
